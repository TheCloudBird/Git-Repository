# 操作系统的启动

  磁盘： 存放OS
  BIOS ： 基本的I/O操作
  bootload: 加载OS

  1. 电脑设备刚开始的启动的时候，需要从一个固定的内存地址进行执行（例如x86是从0xfff0开始的）,该段程序一般称为boot,并且存放在rom中。 
  2. boot的主要任务是进行设备自检（post)和在磁盘的第一个扇区将bootload（一般为512字节）读取到内存固定的地址（例如x86为0x7fc00）
  3. bootload的主要的任务是将OS读取到内存中，并且执行OS，此时该设备才真正的由操作系统来进行掌握。

# 操作系统对外暴露的接口

操作系统对外暴露的接口有系统调用，异常和中断。其中系统调用和异常是面向应用程序的，中断是面向外设。

## 系统调用

系统调用是应用程序需要操作系统提供服务的请求。

通常情况下，每一个系统调用都有一个序号，操作系统通过序号来维护系统调用的索引表。
系统调用接口（例如C的系统头文件、Java ApI）调用内核态中预期的系统调用

### 系统调用与函数调用的区别

函数调用是在一个栈空间中进行参数的传递和结果的返回，而系统调用是在应用程序和操作系统的两个堆栈中进行参数传递和结果返回

## 异常

异常是应用程序被动的接受操作系统的服务，一般是应用程序执行了非法的指令或错误的操作。

每一个异常都有一个编号，该编号对应着每一异常的服务程序，在操作系统中有一张表管理的这所有的异常，key为异常号，value为异常服务程序的地址。
当一个应用程序执行了一个非法的指令，会产生一个异常的编号，通过该编号，操作系统找到异常服务程序。

和中断相同，在进入中断程序之前要保存当前程序执行的现场，最后要根据异常服务程序返回的结果，来对应用程序执行不同措施，例如杀死应用程序、重新启动应用程序、跳过该异常等。

## 中断

来自不同外设向操作系统发出的请求。
在操作系统中，对不同外设的中断进行编号，每一个中断编号对应某一个外设的中断程序，为了更好的对所有外设的中断进行管理，在操作系统存放着一张表，用key(编号)-value（中断服务程序的编号）的形式进行管理，该表叫做中断向量表。

中断的实现需要硬件和软件的配合

硬件： 产生中断号，操作系统通过中断号找到对应的中断服务程序
软件： 保存当前正在执行程序的所有状态，包括寄存器中的值，堆栈，程序指针等，用来实现中断返回时，再次执行当前程序，该过程叫做保存现场。
       根据中断号找到对应的中断服务程序，并执行
       中断服务程序程序执行完成后，将保存的当前程序的执行过程恢复，此过程叫恢复现场

## 跨越操作系统的边界的开销

跨越操作系统的边界是指 外设到操作系统  应用程序到操作系统以及操作系统到外设  操作系统到应用程序

开销： 
1. 建立中断\异常\系统调用号与对应服务程序的映射关系的开销
2. 建立内核堆栈的开销
3. 检验外设或应用程序传递过来的参数的开销
4. 内核态映射到用户态的地址空间（将内核态执行服务程序的执行的结果复制到应用程序（用户态））  更新页面映射权限（不明白）
5. 内核态独立的地址空间。

# 进程

进程的定义: 一个具有一定独立功能的程序在一个数据集合上的一次动态执行的过程。
一个进程应该包括程序代码、程序处理的数据、程序计数器中的值，指示下一条将运行的指令、一组通用的寄存器的当前值，堆栈、一组系统资源。总之进程包含了正在运行的一个程序的所有状态信息。

进程与程序的关系

 程序是静态的代码，进程是程序动态运行的程序。
 程序是产生进程的基础。
 程序的每次运行构成不同的进程
 进程是程序功能的体现
 通过多次执行，一个程序可以对应多个进程，通过调用过程，一个进程可以包含多个程序。

 进程与程序的区别

 进程是动态的，程序是静态。 程序是一组有序指令的集合，进程是程序的执行，有用户态和核心态。
 进程是暂时的，程序是永久的。 进程是一个状态变化的过程。

 进程的特点： 动态性，并发，独立性，制约性。

 ## 进程的控制块

  进程控制块是操作系统控制进程运行的所用到的信息集合。操作系统通过PCB来描述进程的基本情况以及运行变化的过程，PCB是进程存在的唯一标识。

 进程控制块(PCB)包含3大类信息

1. 进程标识信息。如进程的标识； 本进程的产生者标识； 用户标识
2. 处理机状态信息保存区。 保存进程的运行现场信息：
    （1） 用户可见寄存器，用户程序可以使用的数据，地址等寄存器
     (2)  控制和状态寄存器，如程序计数器（pc），程序状态字（PSW）。
    （3） 栈指针，过程调用/系统调用/中断处理和返回时需要用到它。
3. 进程的控制信息
     调度和状态信息，用于操作系统调度进程并占用处理机使用。
     进程间通信信息，为支持进程的通信的相关标识，信号，信件等。这些信息存放在接收方的进程控制块中。
     存储管理信息，包括有指向本进程映像存储空间的数据结构
     进程所用的资源，说明进程打开，使用的系统资源
     有关数据结构连接信息，进程可以连接到一个进程队列中，或连接到相关的其他进程的PCB。

### PCB的组织方式
    
    链表： 同一状态的进程其PCB成一链表，多个状态对应多个不同的链表，各状态的进程形成不同的链表： 就绪链表，阻塞链表。

    索引表： 同一状态的进程归入一个index表（有index指向pcb），多个状态对应多个不同的index表。

## 进程的生命周期

进程创建  进程就绪  进程运行 进程阻塞 进程唤醒  进程结束 

## 进程挂起

进程被挂起意味着进程没用占用内存空间。

挂起有两种状态
1. 阻塞挂起状态：进程在外存并等待某事件的出现
2. 就绪挂起状态：进程在外存，但只要进入内存就会被运行。

挂起状态的转化

挂起，将进程从内存转到外存，可能有以下几种情况：

1. 阻塞到阻塞挂起：没有进程处于就绪状态或就绪进程要求更多的内存资源时，会进行这种转换，以提交新进程或运行就绪进程（一般在设备比较卡的时候出现）。
2. 就绪到就绪挂起：当有高优先级阻塞（系统会认为很快就绪）的进程和低优先级就绪进程时，系统会选择挂起低优先级就绪进程。
3. 运行到就绪挂起：对抢占式分时系统，当高优先级阻塞挂起进程因事件出现而进入就绪挂起时，系统可能会把运行进程转到就绪挂起状态。

外存时的状态转换

阻塞挂起到就绪挂起：因为某个事件到来时，操作系统会执行这个操纵

解挂/激活：把一个进程从外存转到内存。可能会发生以下情况。
1. 就绪挂起到就绪：没有就绪进程或挂起就绪进程优先级高于就绪进程时，会进行这种转换。
2. 阻塞挂起到阻塞：当一个进程释放内存时，系统会把一个高优先级阻塞挂起进程转换为阻塞进程。

## 状态队列

操作系统维护一组队列来，管理系统中处于不同状态的进程。一般会有两种队列。就绪队列和阻塞队列。


# 线程

线程是进程中的一条流程。

有了线程后对进程的有了新的理解。
1. 从资源角度来说，进程是把一组相关的资源组合起来，构成一个资源平台，包括地址空间、打开的各种文件。
2. 从运行的角度来说，线程是在此资源平台上运行的一段流程。
经过上述描述可以知道进程有两部分组成，资源与线程（执行的过程）。

线程的优点：
线程的缺点：进程中的一个线程崩溃了，进程的其他线程也会崩溃。

## 线程与进程的比较

进程是资源分配的单位，线程是CPU调度的单位。
进程拥有一个完整的资源平台，而线程独占与线程执行相关的资源，如寄存器和栈
线程同样具备就绪、阻塞和执行三种基本状态，同样具有线程之间的转换。
线程能减小并发执行的时间和空间开销，体现在如下几个方面：
1. 线程的创建的时间比进程短。
2. 线程的终止时间比进程短
3. 同一进程内的线程切换时间比进程短
4. 由于同一进程的各线程间共享内存和文件，可以不通过内核进行通信。

## 线程的实现

线程的实现有三中方式： 用户线程、内核线程以及轻量级进程

1. 用户线程
   1） 用户线程是有用户态中的线程，内核看不到线程的存在，因此操作系统不能进行线程的调度，但是能够看到线程所在的进程。
   2） 在用户空间实现线程机制，它不依赖与操作系统的内核，由一组用户级的线程函数来完成线程的管理，包括线程的创建、终止、同步和调度。
   3） 由于用户线程的维护由相应进程来完成（通过线程库函数）,不需要操作系统内核了解用户线程的存在，可用与不支持线程技术的多进程操作系统。
   4） 每个进程都需要自己私有的线程控制块（TCB）列表，用来跟踪记录它的各个线程的状态（pc、栈指针、寄存器），TCB由线程库来维护。
   5） 用户线程的切换也是由线程库来完成的，无需用户态到内核态的切换，所以速度特别快；
   6） 允许每个进程拥有自定义的线程调度算法。
   用户线程的缺点：
    如果一个线程发起系统调用而堵塞，整个进程都要等待。
    当一个线程开始运行后，除非它主动地交出CPU的使用权，否则它所在的进程当中的其他线程将无法运行。
    由于时间片分配给进程，故而与其他进程比，在多线程执行时，每个线程得到的时间片较少，执行会较慢。
2. 内核线程
    内核线程是指在操作系统的内核中实现的一种线程机制（例如 Windows　NT　和　Windows　２０００），由操作系统的内核来完成线程的创建、终止和管理。
    在支持内核线程的操作系统中，由内核来维护进程和线程的上下文信息（PCB与TCB）
    在线程创建、终止和切换都是通过系统调用/内核函数的方式来进行，由内核来完成，因此系统开销较大。
    在一个进程当中，如果某个内核线程发起系统调用而被阻塞，并不会影响其他内核线程的运行。
    时间片分配给线程，多线程的进程获得更多的CPU时间。
３.　轻量级进程（LinghtWeight　process）
    它是内核支持的用户线程。一个进程可有一个或多个轻量级进程，每个量级进程由一个单独的内核线程来支持。（Solaris/Linux）

### 内核线程与用户线程的关系

1. 一个内核线程对应多个用户线程
2. 一个内核线程对应一个用户线程
3. 多个内核线程对应多个用户线程

## 上下文切换

停止当前运行进程（从运行态改变成其他状态）并且调度其他进程（转换成运行状态）

必须在切换之前存储许多部分的进程上下文
必须能够在之后恢复他们，所以进程不能显示它曾经被暂停过。
必须快速（上下文转换非常频繁）