# 操作系统的启动

  磁盘： 存放OS
  BIOS ： 基本的I/O操作
  bootload: 加载OS

  1. 电脑设备刚开始的启动的时候，需要从一个固定的内存地址进行执行（例如x86是从0xfff0开始的）,该段程序一般称为boot,并且存放在rom中。 
  2. boot的主要任务是进行设备自检（post)和在磁盘的第一个扇区将bootload（一般为512字节）读取到内存固定的地址（例如x86为0x7fc00）
  3. bootload的主要的任务是将OS读取到内存中，并且执行OS，此时该设备才真正的由操作系统来进行掌握。

# 操作系统对外暴露的接口

操作系统对外暴露的接口有系统调用，异常和中断。其中系统调用和异常是面向应用程序的，中断是面向外设。

## 系统调用

系统调用是应用程序需要操作系统提供服务的请求。

通常情况下，每一个系统调用都有一个序号，操作系统通过序号来维护系统调用的索引表。
系统调用接口（例如C的系统头文件、Java ApI）调用内核态中预期的系统调用

### 系统调用与函数调用的区别

函数调用是在一个栈空间中进行参数的传递和结果的返回，而系统调用是在应用程序和操作系统的两个堆栈中进行参数传递和结果返回

## 异常

异常是应用程序被动的接受操作系统的服务，一般是应用程序执行了非法的指令或错误的操作。

每一个异常都有一个编号，该编号对应着每一异常的服务程序，在操作系统中有一张表管理的这所有的异常，key为异常号，value为异常服务程序的地址。
当一个应用程序执行了一个非法的指令，会产生一个异常的编号，通过该编号，操作系统找到异常服务程序。

和中断相同，在进入中断程序之前要保存当前程序执行的现场，最后要根据异常服务程序返回的结果，来对应用程序执行不同措施，例如杀死应用程序、重新启动应用程序、跳过该异常等。

## 中断

来自不同外设向操作系统发出的请求。
在操作系统中，对不同外设的中断进行编号，每一个中断编号对应某一个外设的中断程序，为了更好的对所有外设的中断进行管理，在操作系统存放着一张表，用key(编号)-value（中断服务程序的编号）的形式进行管理，该表叫做中断向量表。

中断的实现需要硬件和软件的配合

硬件： 产生中断号，操作系统通过中断号找到对应的中断服务程序
软件： 保存当前正在执行程序的所有状态，包括寄存器中的值，堆栈，程序指针等，用来实现中断返回时，再次执行当前程序，该过程叫做保存现场。
       根据中断号找到对应的中断服务程序，并执行
       中断服务程序程序执行完成后，将保存的当前程序的执行过程恢复，此过程叫恢复现场

## 跨越操作系统的边界的开销

跨越操作系统的边界是指 外设到操作系统  应用程序到操作系统以及操作系统到外设  操作系统到应用程序

开销： 
1. 建立中断\异常\系统调用号与对应服务程序的映射关系的开销
2. 建立内核堆栈的开销
3. 检验外设或应用程序传递过来的参数的开销
4. 内核态映射到用户态的地址空间（将内核态执行服务程序的执行的结果复制到应用程序（用户态））  更新页面映射权限（不明白）
5. 内核态独立的地址空间。

# 进程

进程的定义: 一个具有一定独立功能的程序在一个数据集合上的一次动态执行的过程。
一个进程应该包括程序代码、程序处理的数据、程序计数器中的值，指示下一条将运行的指令、一组通用的寄存器的当前值，堆栈、一组系统资源。总之进程包含了正在运行的一个程序的所有状态信息。

进程与程序的关系

 程序是静态的代码，进程是程序动态运行的程序。
 程序是产生进程的基础。
 程序的每次运行构成不同的进程
 进程是程序功能的体现
 通过多次执行，一个程序可以对应多个进程，通过调用过程，一个进程可以包含多个程序。

 进程与程序的区别

 进程是动态的，程序是静态。 程序是一组有序指令的集合，进程是程序的执行，有用户态和核心态。
 进程是暂时的，程序是永久的。 进程是一个状态变化的过程。

 进程的特点： 动态性，并发，独立性，制约性。

 ## 进程的控制块

  进程控制块是操作系统控制进程运行的所用到的信息集合。操作系统通过PCB来描述进程的基本情况以及运行变化的过程，PCB是进程存在的唯一标识。

 进程控制块(PCB)包含3大类信息

1. 进程标识信息。如进程的标识； 本进程的产生者标识； 用户标识
2. 处理机状态信息保存区。 保存进程的运行现场信息：
    （1） 用户可见寄存器，用户程序可以使用的数据，地址等寄存器
     (2)  控制和状态寄存器，如程序计数器（pc），程序状态字（PSW）。
    （3） 栈指针，过程调用/系统调用/中断处理和返回时需要用到它。
3. 进程的控制信息
     调度和状态信息，用于操作系统调度进程并占用处理机使用。
     进程间通信信息，为支持进程的通信的相关标识，信号，信件等。这些信息存放在接收方的进程控制块中。
     存储管理信息，包括有指向本进程映像存储空间的数据结构
     进程所用的资源，说明进程打开，使用的系统资源
     有关数据结构连接信息，进程可以连接到一个进程队列中，或连接到相关的其他进程的PCB。

### PCB的组织方式
    
    链表： 同一状态的进程其PCB成一链表，多个状态对应多个不同的链表，各状态的进程形成不同的链表： 就绪链表，阻塞链表。

    索引表： 同一状态的进程归入一个index表（有index指向pcb），多个状态对应多个不同的index表。

## 进程的生命周期

进程创建  进程就绪  进程运行 进程阻塞 进程唤醒  进程结束 

## 进程挂起

进程被挂起意味着进程没用占用内存空间。

挂起有两种状态
1. 阻塞挂起状态：进程在外存并等待某事件的出现
2. 就绪挂起状态：进程在外存，但只要进入内存就会被运行。

挂起状态的转化

挂起，将进程从内存转到外存，可能有以下几种情况：

1. 阻塞到阻塞挂起：没有进程处于就绪状态或就绪进程要求更多的内存资源时，会进行这种转换，以提交新进程或运行就绪进程（一般在设备比较卡的时候出现）。
2. 就绪到就绪挂起：当有高优先级阻塞（系统会认为很快就绪）的进程和低优先级就绪进程时，系统会选择挂起低优先级就绪进程。
3. 运行到就绪挂起：对抢占式分时系统，当高优先级阻塞挂起进程因事件出现而进入就绪挂起时，系统可能会把运行进程转到就绪挂起状态。

外存时的状态转换

阻塞挂起到就绪挂起：因为某个事件到来时，操作系统会执行这个操纵

解挂/激活：把一个进程从外存转到内存。可能会发生以下情况。
1. 就绪挂起到就绪：没有就绪进程或挂起就绪进程优先级高于就绪进程时，会进行这种转换。
2. 阻塞挂起到阻塞：当一个进程释放内存时，系统会把一个高优先级阻塞挂起进程转换为阻塞进程。

## 状态队列

操作系统维护一组队列来，管理系统中处于不同状态的进程。一般会有两种队列。就绪队列和阻塞队列。


# 线程

线程是进程中的一条流程。

有了线程后对进程的有了新的理解。
1. 从资源角度来说，进程是把一组相关的资源组合起来，构成一个资源平台，包括地址空间、打开的各种文件。
2. 从运行的角度来说，线程是在此资源平台上运行的一段流程。
经过上述描述可以知道进程有两部分组成，资源与线程（执行的过程）。

线程的优点：
线程的缺点：进程中的一个线程崩溃了，进程的其他线程也会崩溃。

## 线程与进程的比较

进程是资源分配的单位，线程是CPU调度的单位。
进程拥有一个完整的资源平台，而线程独占与线程执行相关的资源，如寄存器和栈
线程同样具备就绪、阻塞和执行三种基本状态，同样具有线程之间的转换。
线程能减小并发执行的时间和空间开销，体现在如下几个方面：
1. 线程的创建的时间比进程短。
2. 线程的终止时间比进程短
3. 同一进程内的线程切换时间比进程短
4. 由于同一进程的各线程间共享内存和文件，可以不通过内核进行通信。

## 线程的实现

线程的实现有三中方式： 用户线程、内核线程以及轻量级进程

1. 用户线程
   1） 用户线程是有用户态中的线程，内核看不到线程的存在，因此操作系统不能进行线程的调度，但是能够看到线程所在的进程。
   2） 在用户空间实现线程机制，它不依赖与操作系统的内核，由一组用户级的线程函数来完成线程的管理，包括线程的创建、终止、同步和调度。
   3） 由于用户线程的维护由相应进程来完成（通过线程库函数）,不需要操作系统内核了解用户线程的存在，可用与不支持线程技术的多进程操作系统。
   4） 每个进程都需要自己私有的线程控制块（TCB）列表，用来跟踪记录它的各个线程的状态（pc、栈指针、寄存器），TCB由线程库来维护。
   5） 用户线程的切换也是由线程库来完成的，无需用户态到内核态的切换，所以速度特别快；
   6） 允许每个进程拥有自定义的线程调度算法。
   用户线程的缺点：
    如果一个线程发起系统调用而堵塞，整个进程都要等待。
    当一个线程开始运行后，除非它主动地交出CPU的使用权，否则它所在的进程当中的其他线程将无法运行。
    由于时间片分配给进程，故而与其他进程比，在多线程执行时，每个线程得到的时间片较少，执行会较慢。
2. 内核线程
    内核线程是指在操作系统的内核中实现的一种线程机制（例如 Windows　NT　和　Windows　２０００），由操作系统的内核来完成线程的创建、终止和管理。
    在支持内核线程的操作系统中，由内核来维护进程和线程的上下文信息（PCB与TCB）
    在线程创建、终止和切换都是通过系统调用/内核函数的方式来进行，由内核来完成，因此系统开销较大。
    在一个进程当中，如果某个内核线程发起系统调用而被阻塞，并不会影响其他内核线程的运行。
    时间片分配给线程，多线程的进程获得更多的CPU时间。
３.　轻量级进程（LinghtWeight　process）
    它是内核支持的用户线程。一个进程可有一个或多个轻量级进程，每个量级进程由一个单独的内核线程来支持。（Solaris/Linux）

### 内核线程与用户线程的关系

1. 一个内核线程对应多个用户线程
2. 一个内核线程对应一个用户线程
3. 多个内核线程对应多个用户线程

## 上下文切换

停止当前运行进程（从运行态改变成其他状态）并且调度其他进程（转换成运行状态）

必须在切换之前存储许多部分的进程上下文
必须能够在之后恢复他们，所以进程不能显示它曾经被暂停过。
必须快速（上下文转换非常频繁）

## 进程的创建与执行

fork() 在unix中执行fork()系统调用，会创建一个与父进程基本一致的子进程，其实该子进程是父进程的一个副本。然后通过执行exec()系统调用来执行属于子进程自己的内容。

### fork()的简单实现：

1. 对子进程分配内存
2. 复制父进程的内存和cpu寄存器到子进程里
3. fork()该方式开销昂贵

**在99%的情况下，我们在调用fork()之后调用exec();**

4. 在fork()操作中内存复制是没有作用的
5. 子进程可能关闭打开的文件和连接
6. 开销因此是高的

### vfork()

1. 一个创建进程的系统调用，不需要创建一个同样的内存映像(不需要复制父进程的全部的内容)
2. 一些时候称为轻量级fork()
3. 子进程应该几乎立即调用exec()
4. 使用Copy on Write (cow) 写时复制技术。

## 进程的等待与终止

wait()系统调用是被父进程用来等待子进程的结束。

**为什么父进程要等待子进程的结束， 因为当子程序执行exit时，exit会回收子进程用到或打开的资源，释放子进程占用的空间，但是有一个东西exit无法进行回收，那就是代表该子进程的标识（PCB）,该子进程的PCB，只能交给父进程来进程处理。由上可知，一个子进程的结束是通过执行该子进程的exit和该子进程的父进程的wait来实现的**

一个子进程向父进程返回一个值，所以父进程必须接受这个值并处理。
wait()系统调用担任这个要求。
1. 它使父进程去睡眠来等待子进程的结果。
2. 当一个子进程调用exit()的时候，操作系统解锁父进程，并且通过exit()传递得到的返回值作为wait()调用的一个结果（连同子进程的pid），如果没有子进程存活，wait()立刻返回。
3. 当然如果这里有为父进程的僵尸等待，wait()立即返回其中一个值，并且解除僵尸状态。

进程结束执行后，它调用exit()
这个系统调用:
1. 将这程序的"结果"作为一个参数
2. 关闭所有打开的文件，连接等。
3. 释放内存。
4. 释放大部分支持进程的操作系统结构
5. 检查父进程是否是存活的，如果是存活的，它保留结果的值直到父进程需要它；在这种情况下，进程没有真正死亡，但是它进入了僵尸状态（zombie/defunct）.也就说在子进程执行exit()之后,到父进程执行wait()之前，子线程没有彻底的结束。 如果不是存活的，它会释放所有的数据结构，这个进程死亡。
6. 清理所有等待的僵尸进程。

进程终止后是最终的垃圾收集（资源回收）。 在操作系统中有一个根进程（祖宗进程），它会定时的扫描pcb的列表，查找处于僵尸状态的进程，并将这些进程结束（回收）。 

## CPU调度

CPU调度的条件：
1. 一个进程从运行状态切换到等待状态
2. 一个进程被终结了

3. 不可被抢占  调度程序必须等待事件结束
4. 可以被抢占  调度程序在中断响应后执行. 当前的进程从运行切换到就绪，或者一个进程从等待切换到就绪。 当前运行的进程可以被换出。

**能否被抢占可以分为用户态能否被抢占和内核态能否被抢占**

### CPU调度的原则
　
１.　执行模型：程序在CPU突发和I/O交替
    (1) 每个调度决定都是关于在下一个CPU突发时将哪个工作交给CPU
    (2) 在时间片机制下，线程可能在结束当前CPU突发前被迫放弃CPU

2. cpu调度算法的评价标准
    (1) CPU使用率　CPU处于忙状态所占时间的百分比
    (2) 吞吐量     在单位时间内完成的进程数量
    (3) 周转时间    一个进程从初始化到结束，包括所有等待时间所花费的时间
    (4) 等待时间    进程在就绪队列中的总时间
    (5) 响应时间    从一个请求被提交到产生第一次响应所花费的总时间

 3. cpu调度算的要求
    (1) 减少响应时间。 
    (2) 减少平均响应时间的波动
    (3) 增加吞吐量 两个方面：减少开销、系统资源的高效利用
    (4) 减少等待时间
    (5) 实现各个进程的公平。 例如：保证每个进程占用相同的CPU时间。 保证每个进程都等待相同的时间。
　
### 调度算法
 1. FCFS - First Come, First Served（先来先服务）
 2. SPN(SJF) SRT - Shortest Process Next(Shortest Job First) Shortest Remaining Time  (短进程优先（短作业优先) 短剩余时间优先)
 3. HRRN - Highest Response Ratio Next (最高响应比优先)
 4. Round Robin - （轮循）
 5. Multilevel Feekback Queues (多级反馈队列)
 6. Fair Share Scheduling （公平共享调度）