# C++ STL

## 模板

### 模板的起源

#### 使用宏摆脱数据类型的限制

宏是在预处理阶段针对代码的纯文本替换

宏本身没有函数的语义（不会对数据类型进行检查）

因此可以借助参数宏虽然可以摆脱类型的约束和限制，但同时也丧失了对数据类型的检查

#define Max(x,y)  x > y ? x  :  y

#### 利用宏构建通用函数框架

利用实例化宏。让预处理器将这个宏代换为针对不同数据类型的真正函数

将宏的通用性和函数的类型安全性完美结合起来

~~~C++
#define MAX(T)   T  max_##T(T x, T y) { \                // ## 在宏中为拼接符， 即将两个内容拼接起来    \ 在宏中为换行符
                      return x > y ? x : y\
                   }

// 实例化宏
MAX(int)
MAX(double)
MAX(string)

#define Max(T) max_##T
    
 // 直接调用
    Max(int)(x,y);
~~~

### 函数模板

函数模板并非真正的函数

#### 函数模板的定义形式

~~~
template <class T1, class T2, ....>  返回值类型 函数模板名(T1,T2, ...)
{
   ....
}

例如： template <class T> T Max(T x, T y){
                    return x > y ? x : y;
          }
~~~

#### 函数模板的使用

~~~
形式： 函数模板 <T1.T2>(调用实参，调用实参)
例如  Max<int> (123,456)
~~~

#### 函数模板的分析

编译器并不是把函数模板编译成一个可以处理任何数据类型的单一实体

编译器在实例化函数模板时根据类型实参从函数模板中产生一个真正的函数实体

函数模板并不是一个函数实体，通过实例化才能产生真正的函数实体

函数模板可以看成编译器生成函数实体的一个依据而已

这种用具体数据类型替换函数模板类型形参的过程叫实例化。这个过程产生一个函数模板的实体

只要使用函数模板，就会自动引发编译器的实例化过程，因此程序员不需要额外地请求对函数模板的实例化

函数模板实例化的条件

原则上来说可以使用任何类型来实例化函数模板，不管其为基本类型还是类类型。

但前提是这个类型必须支持函数模板所要执行的操作

#### 函数模板的扩展

##### 二次编译

编译器对函数模板都会进行两次编译

第一次编译发生在实例化函数模板之前（产生真正函数实体之前）只检查函数模板本身内部代码，查看基本词法是否正确

1. 函数模板内部出现的所有标识符是否均有声明
2. 对于已知类型的调用要查看调用是否有效
3. 对于未知类型调用认为都合理（但是不能包含<>）

第二次编译发生在实例化函数模板之后（产生真正函数实体之后）

结合所使用的类型实参，再次检查模板代码，查看所有调用是否真的均有效。

##### 隐式推断类型实参

如果函数模板的调用形参和类型形参相关。 例如 template <class T> Max(T x, T y) {....}

那么在实例化函数模板时即使不显示指明函数模板的类型实参，编译器也有能力根据调用实参的类型隐式推断出正确的类型实参的类型 例如： Max(123.456); -> Max<int>(123,456);

获得和调用普通函数一致的语法表现形式

三种情况不能做隐式推断

1. 调用参数和类型参数 不完全相关 例如： template<class T, class D> T Max(T x, T y){}
2. 隐式推断不支持隐式类型转换 例如：template <class T> Max(T x, T y){...}   使用时： Max(123,45.6)
3. 返回值类型不支持隐式推断。

#### 函数模板的重载

普通函数和实例化出该函数的函数模板构成重载关系。在数据类型匹配度完全相同的情况下编译器优先选择普通函数，除非函数模板可以产生具有更好的数据类型匹配度的实例。

函数模板的实例化不支持隐式类型转换但普通函数支持。在传递参数时，如果需要编译器做隐式类型转换，则编译器选择普通函数。

可以在实例化时使用<>强行通知编译器选择函数模板